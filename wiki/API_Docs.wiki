#summary Codec API Documentation

(This is a work in progress.)

LZHAM can be used by statically linking the calling application against the two libraries lzhamdecomp.lib and lzhamcomp.lib, or by dynamically loading the codec as a DLL (lzham_x86.dll or lzham_x64.dll under Win32). (Note: Currently, only Win32 supports dynamic linking.) Apps that use static linking and don't require compression functionality only need to link against lzhamdecomp.lib. Apps that use static linking that need compression functionality must link against both libs (even if decompression functionality is not needed) because the compressor relies on functionality present in the decompression lib. (The actual lib names are lib/x86/lzhamcomp_x86.lib, lib/x64/lzhamcomp_x64.lib, etc. See the {{{lib}}} directory.)

The public API is defined in {{{include/lzham.h}}}. This is a C-style API containing functions for streaming or single function call compression and decompression, a function to return the codec's version, and a function that allows the user to override how the codec alllocates memory. The compression/decompression functions are somewhat similar to zlib's or LZMA's. (At some point I'll be adding zlib emulation to LZHAM, using functionality present in my [http://code.google.com/p/miniz miniz] project.)

A set of strictly optional helper classes that simplify loading and using the DLL interface are defined in {{{include/lzham_dynamic_lib.h}}} and {{{include/lzham_static_lib.h}}}. 

Currently, the only working example of these API's is in the command line test app {{{lzhamtest/lzhamtest.cpp}}}.

All private LZHAM code is placed in the {{{lzham}}} namespace. All public API's begin with "lzham_".

Note: The two lib structure present in the LZHAM distribution is optional. It may be more convienent to just copy all .cpp/.h files in the {{{include}}}, {{{lzhamcomp}}} and {{{lzhamdecomp}}} directories into a single directory and then compile/link these files directly into the user's application.

== A Note on Thread Safety ==

All codec state (excluding the memory allocation callback functions, which are global pointers) is stored within user-managed compression/decompression state objects (created by {{{lzham_compress_init()}}} or {{{lzham_decompress_init()}}}), so the codec is thread safe (i.e. multiple compressors/decompressors may be active simultaneously on _different_ state objects). 

However, on a single state object, the compression/decompression API's are not thread safe (i.e. the API's don't do any locking for you at the state object level). In other words, don't do something like calling {{{lzham_compress()}}} simultaneously from multiple threads on the _same_ state object - bad things will happen. 

= API Categories =

== Versioning ==

{{{
   lzham_uint32 lzham_get_version(void);
}}}

Returns the codec's version. The high byte contains the major version (currently 0x10), and the low byte contains the minor version (0x07 in the alpha7 release).

== Custom Memory Allocation Callbacks ==

{{{
   #define LZHAM_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2

   typedef void*  (*lzham_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);
   typedef size_t (*lzham_msize_func)(void* p, void* pUser_data);

   void lzham_set_memory_callbacks(lzham_realloc_func pRealloc, lzham_msize_func pMSize, void* pUser_data);
}}}

By default, the codec calls the usual C-API's to manage memory ({{{malloc}}}, {{{realloc}}}, {{{free}}}, etc.). Call {{{lzham_set_memory_callbacks}}} to globally override this behavior. The user must implement two callbacks, one to handle block allocation/reallocation/freeing, and another that returns the size of allocated blocks.

Avoid calling this function if there are any currently active compression/decompression state objects. This function is not thread safe.

The custom realloc and msize functions must be implemented in a thread safe manner. These functions can be called from multiple threads when threaded compression is enabled.

=== realloc callback ===

The custom reallocation function callback {{{lzham_realloc_func}}} must examine its input parameters to determine the caller's actual intent. If the input pointer {{{p}}} is NULL, the caller wants to allocate a block which must be at least as large as {{{size}}}. NULL is returned if the allocation fails. 

If {{{p}}} is not NULL but {{{size}}} is 0, the caller wants to free the block pointed to by {{{p}}}. 

Otherwise, the caller wants to attempt to change the size of the block pointed to by {{{p}}}. In this case, if {{{movable}}} is true, it is acceptable to physically move the block to satisfy the reallocation request. If {{{movable}}} is false, the block *must not* be moved. NULL is returned if reallocation fails for any reason. In this case, the original allocated block must remain allocated.

If {{{pActual_size}}} is not NULL, {{{*pActual_size}}} should be set to the actual size of the returned block. See the default function {{{lzham_default_realloc}}} in lzhamdecomp/lzham_mem.cpp for a working example.

=== msize callback ===

The custom memory size callback {{{lzham_msize_func}}} must return the actual size of the allocated block pointed to by {{{p}}}, or 0 if {{{p}}} is NULL. The default implementation just calls {{{_msize}}}.

== Compression ==

=== Important Macros ===
{{{
   #define LZHAM_MIN_DICT_SIZE_LOG2 15
   #define LZHAM_MAX_DICT_SIZE_LOG2_X86 26
   #define LZHAM_MAX_DICT_SIZE_LOG2_X64 29
}}}

Compression requires at least dict_size+65536+dict_size*4*2+65536*4 bytes of available heap memory. Under x86, the maximum supported dictionary size is 2^26^ (64MB), and under x64 the maximum is currently 2^29^ (512MB). The minimum supported dictionary size is 32KB, but note the codec hasn't really been tuned for max throughput or coding efficiency with tiny dictionary sizes.

{{{
   #define LZHAM_MAX_HELPER_THREADS 16
}}}

The compressor can optionally create up to LZHAM_MAX_HELPER_THREADS "helper" threads to assist in compression. These helper threads can be used to accelerate parsing and match finding. Note, the original calling thread is NOT included in this total. For example, if the # of helper threads is 4, up to 5 threads total will be involved in compression (the calling thread plus 4 additional threads). Decompression is always single threaded.

=== Compression Related Enums ===
==== lzham_compress_status_t ====

{{{
   enum lzham_compress_status_t
   {
      LZHAM_COMP_STATUS_NOT_FINISHED = 0,
      LZHAM_COMP_STATUS_NEEDS_MORE_INPUT,

      // All the following enums must indicate failure/success.
      LZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      LZHAM_COMP_STATUS_SUCCESS = LZHAM_COMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,
      LZHAM_COMP_STATUS_FAILED,
      LZHAM_COMP_STATUS_FAILED_INITIALIZING,
      LZHAM_COMP_STATUS_INVALID_PARAMETER,
      LZHAM_COMP_STATUS_OUTPUT_BUF_TOO_SMALL
   };
}}}

{{{lzham_compress_status_t}}} defines the possible return status codes from the compressor. The first set of codes (NOT_FINISHED and NEEDS_MORE_INPUT) indicate that the compressor can't continue because the input buffer is empty, and/or the output buffer is full. The rest of the codes indicate either a success or failure condition.

==== lzham_compress_level ====
{{{
   enum lzham_compress_level
   {
      LZHAM_COMP_LEVEL_FASTEST = 0,
      LZHAM_COMP_LEVEL_FASTER,
      LZHAM_COMP_LEVEL_DEFAULT,
      LZHAM_COMP_LEVEL_BETTER,
      LZHAM_COMP_LEVEL_UBER,

      LZHAM_TOTAL_COMP_LEVELS
   };
}}}

{{{lzham_compress_level}}} allows the caller to control the tradeoff between compression ratio and throughput. {{{LZHAM_COMP_LEVEL_FASTEST}}} is the fastest level with the lowest compression, and {{{LZHAM_COMP_LEVEL_UBER}}} is the slowest level with highest compression.

==== lzham_compress_flags ====
{{{
   enum lzham_compress_flags
   {
      LZHAM_COMP_FLAG_FORCE_POLAR_CODING = 1,      
      LZHAM_COMP_FLAG_EXTREME_PARSING = 2,         
      LZHAM_COMP_FLAG_DETERMINISTIC_PARSING = 4,   
      LZHAM_COMP_FLAG_TRADEOFF_DECOMPRESSION_RATE_FOR_COMP_RATIO = 16,
   };
}}}


{{{lzham_compress_flags}}} define the various flags that may be logically OR'd together:

{{{LZHAM_COMP_FLAG_FORCE_POLAR_CODING}}}: Forces Polar codes vs. Huffman, for a slight increase in decompression speed.

{{{LZHAM_COMP_FLAG_EXTREME_PARSING}}}: Improves ratio by allowing the compressor's parse graph to grow "higher" (up to 4 parent nodes per output node), but is much slower.

{{{LZHAM_COMP_FLAG_DETERMINISTIC_PARSING}}}: Guarantees that the compressed output will always be the same given the same input data, the same compression parameters, and the same build. Otherwise, the compressed output stream may vary a small amount due to kernel threading scheduling differences between runs.

{{{LZHAM_COMP_FLAG_TRADEOFF_DECOMPRESSION_RATE_FOR_COMP_RATIO}}}:
If enabled, the compressor is free to use any optimizations which could lower the decompression throughput rate but improve ratio. For example, the compressor may adaptively reset the Huffman table update rate to maximum frequency if doing so would improve ratio, which is expensive for the decompressor.

=== Compression Parameters Struct ===

{{{
   struct lzham_compress_params
   {
      lzham_uint32 m_struct_size;            
      lzham_uint32 m_dict_size_log2;         
      lzham_compress_level m_level;          
      lzham_uint32 m_max_helper_threads;     
      lzham_uint32 m_cpucache_total_lines;   
      lzham_uint32 m_cpucache_line_size;     
      lzham_uint32 m_compress_flags;         
      lzham_uint32 m_num_seed_bytes;         
      const void *m_pSeed_bytes;
   };
}}}

{{{lzham_compress_params}}} contains various initialization parameters. The caller should clear this structure to all-0's, set {{{m_struct_size}}} to sizeof(lzham_compress_params}, then fill in these parameters:

{{{m_dict_size_log2}}}: Set to the log2(dictionary_size), must range between [{{{LZHAM_MIN_DICT_SIZE_LOG2}}}, {{{LZHAM_MAX_DICT_SIZE_LOG2_X86}}}] for x86 or {{{LZHAM_MAX_DICT_SIZE_LOG2_X64}}} for x64. See [API_Docs#Important_Macros Important Macros].

{{{m_level}}}: Compression level. Set to LZHAM_COMP_LEVEL_FASTEST, etc. See the [API_Docs#lzham_compress_level lzham_compress_level] enum.

{{{m_max_helper_threads}}}: Maximum # of additional "helper" threads to create, must range between [0,{{{LZHAM_MAX_HELPER_THREADS}}}]. See [API_Docs#Important_Macros Important Macros].

{{{m_cpucache_total_lines}}}: Set to 0 (optimize compressed stream to avoid L1/L2 cache misses - not currently supported)

{{{m_cpucache_line_size}}}: Set to 0

{{{m_compress_flags}}}: Optional compression flags (see lzham_compress_flags enum)

{{{m_num_seed_bytes}}}: Optional, for delta compression. Set to the number of seed bytes pointed to by m_pSeed_bytes. This value must be less than or equal to the size of the dictionary size.

{{{m_pSeed_bytes}}}: Optional, for delta compression. Pointer to seed bytes buffer. Buffer must be at least m_num_seed_bytes long.

=== Compression Functions ===

==== lzham_compress_init =====
{{{
   lzham_compress_state_ptr lzham_compress_init(const lzham_compress_params *pParams);
}}}

==== lzham_compress_deinit ====
{{{
   lzham_uint32 lzham_compress_deinit(lzham_compress_state_ptr pState);
}}}

==== lzham_compress ====
{{{
   lzham_compress_status_t lzham_compress(
      lzham_compress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);
}}}

==== lzham_compress_memory ====
{{{
  lzham_compress_status_t lzham_compress_memory(
      const lzham_compress_params *pParams,
      lzham_uint8* pDst_buf,
      size_t *pDst_len,
      const lzham_uint8* pSrc_buf,
      size_t src_len,
      lzham_uint32 *pAdler32);
}}}

== Decompression ==

=== Decompression Enums ===

==== lzham_decompress_status_t ====
{{{
   enum lzham_decompress_status_t
   {
      LZHAM_DECOMP_STATUS_NOT_FINISHED = 0,
      LZHAM_DECOMP_STATUS_NEEDS_MORE_INPUT,

      // All the following enums always (and MUST) indicate failure/success.
      LZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      LZHAM_DECOMP_STATUS_SUCCESS = LZHAM_DECOMP_STATUS_FIRST_SUCCESS_OR_FAILURE_CODE,

      LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE,

      LZHAM_DECOMP_STATUS_FAILED_INITIALIZING = LZHAM_DECOMP_STATUS_FIRST_FAILURE_CODE,
      LZHAM_DECOMP_STATUS_FAILED_DEST_BUF_TOO_SMALL,
      LZHAM_DECOMP_STATUS_FAILED_HAVE_MORE_OUTPUT,
      LZHAM_DECOMP_STATUS_FAILED_EXPECTED_MORE_RAW_BYTES,
      LZHAM_DECOMP_STATUS_FAILED_BAD_CODE,
      LZHAM_DECOMP_STATUS_FAILED_ADLER32,
      LZHAM_DECOMP_STATUS_FAILED_BAD_RAW_BLOCK,
      LZHAM_DECOMP_STATUS_FAILED_BAD_COMP_BLOCK_SYNC_CHECK,
      LZHAM_DECOMP_STATUS_INVALID_PARAMETER,
   };
}}}

=== Decompression Functions ===

==== lzham_decompress_init ====
{{{
   lzham_decompress_state_ptr lzham_decompress_init(const lzham_decompress_params *pParams);
}}}

==== lzham_decompress_reinit ====
{{{
   lzham_decompress_state_ptr lzham_decompress_reinit(lzham_decompress_state_ptr pState, 
      const lzham_decompress_params *pParams);
}}}

==== lzham_decompress_deinit ====
{{{
   lzham_uint32 lzham_decompress_deinit(lzham_decompress_state_ptr pState);
}}}


==== lzham_decompress ====
{{{
   lzham_decompress_status_t lzham_decompress(
      lzham_decompress_state_ptr pState,
      const lzham_uint8 *pIn_buf, size_t *pIn_buf_size,
      lzham_uint8 *pOut_buf, size_t *pOut_buf_size,
      lzham_bool no_more_input_bytes_flag);
}}}

==== lzham_decompress_memory ====
{{{
   lzham_decompress_status_t lzham_decompress_memory(
      const lzham_decompress_params *pParams,
      lzham_uint8* pDst_buf,
      size_t *pDst_len,
      const lzham_uint8* pSrc_buf,
      size_t src_len,
      lzham_uint32 *pAdler32);
}}}